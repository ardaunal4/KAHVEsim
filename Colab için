#I don't have an NVIDIA GPU, so I wrote the code in a way Google Colab could run it, you can ignore the first %%writefile part if you have an NVIDIA GPU.
# Write the C++/CUDA code to a file, you can then run the simulation by first executing "!nvcc -o electron_simulation electron_simulation.cu", then "!./electron_simulation"
%%writefile electron_simulation.cu

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <random>
#include <cuda_runtime.h>
#include <device_launch_parameters.h>

//define the necessary constants
#define MASS_ELECTRON 9.10938356e-31f
#define CHARGE_ELECTRON -1.602176634e-19f

const float SIMULATION_TIME = 1e-9; // 1 ns
//read the csv file

std::vector<float> ReadCSV(const std::string &filename) {
  std::ifstream file(filename);
  std::string line;
  std::vector<float> data;
  int dataPts = 0;

  while(std::getline(file, line)) {
    std::stringstream ss(line);
    std::string value;

  while(std::getline(ss, value, ',')){

    try {
    float val = std::stof(value);
    data.push_back(val);
    dataPts++;
} catch (const std::invalid_argument &e) {
    std::cerr << "Invalid number: " << value << std::endl;
    break;
} catch (const std::out_of_range &e) {
    std::cerr << "Out of range number: " << value << std::endl;
    break;
}

  }

}
return data;
}


std::vector<float> init_Electron() {
    int num_electrons = 1000; // number of electrons to be generated
    float pos_mean_x = 0.0; // position and velocity distribution parameters
    float pos_stddev_x = 0.0001;  
    float pos_mean_y = 0.0;
    float pos_stddev_y = 0.01;  
    float pos_mean_z = 0.0;
    float pos_stddev_z = 0.01;  
    float vel_mean_x = 0.0;
    float vel_stddev_x = 1.0;  
    float vel_mean_y = 0.0;
    float vel_stddev_y = 1.0;  
    float vel_mean_z = 0.0;
    float vel_stddev_z = 1.0;  
    
    //start generating

    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<double> pos_x(pos_mean_x, pos_stddev_x);
    std::normal_distribution<double> pos_y(pos_mean_y, pos_stddev_y);
    std::normal_distribution<double> pos_z(pos_mean_z, pos_stddev_z);
    std::normal_distribution<double> vel_x(vel_mean_x, vel_stddev_x);
    std::normal_distribution<double> vel_y(vel_mean_y, vel_stddev_y);
    std::normal_distribution<double> vel_z(vel_mean_z, vel_stddev_z);

    std::vector<float> electrons(num_electrons * 6);

    for (int i = 0; i < num_electrons * 6; i = i + 6) {
      electrons[i] = pos_x(gen);
      electrons[i+1] = pos_y(gen);
      electrons[i+2] = pos_z(gen);
      electrons[i+3] = vel_x(gen);
      electrons[i+4] = vel_y(gen);
      electrons[i+5] = vel_z(gen);
    }

    for (int i = 0; i < 3; i++) {
        std::cout << "Electron " << i+1 << ": "
                  << "x=" << electrons[i*6+0] << ", "
                  << "y=" << electrons[i*6+1] << ", "
                  << "z=" << electrons[i*6+2] << ", "
                  << "vx=" << electrons[i*6+3] << ", "
                  << "vy=" << electrons[i*6+4] << ", "
                  << "vz=" << electrons[i*6+5] << std::endl;
    }  
return electrons;      
}

__device__ int nearest_Index(float x, float y, float z, const float* d_field, int num_field_points) {
    float min_dist = 1e30f;
    int min_index = -1;
    for (int i = 0; i < num_field_points; ++i) {
        float dx = d_field[i * 6 + 0] - x;
        float dy = d_field[i * 6 + 1] - y;
        float dz = d_field[i * 6 + 2] - z;
        float dist = dx*dx + dy*dy + dz*dz;
        if (dist < min_dist) {
            min_dist = dist;
            min_index = i;
        }
    }
    return min_index;
}

__global__ void leapfrog_kernel(float* d_electrons, const float* d_field, int num_electrons, int num_field_points, float dt) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= num_electrons) return;

    int e_offset = idx * 6;
    float x = d_electrons[e_offset + 0];
    float y = d_electrons[e_offset + 1];
    float z = d_electrons[e_offset + 2];
    float vx = d_electrons[e_offset + 3];
    float vy = d_electrons[e_offset + 4];
    float vz = d_electrons[e_offset + 5];

    float halfDt = dt / 2.0f;

    // leapfrog step 1 
    x += vx * halfDt;
    y += vy * halfDt;
    z += vz * halfDt;

    // find nearest data point for step 2
    int field_index = nearest_Index(x, y, z, d_field, num_field_points);

    // leapfrog step 2
    float ax = d_field[field_index * 6 + 3] * CHARGE_ELECTRON / MASS_ELECTRON;
    float ay = d_field[field_index * 6 + 4] * CHARGE_ELECTRON / MASS_ELECTRON;
    float az = d_field[field_index * 6 + 5] * CHARGE_ELECTRON / MASS_ELECTRON;
    vx += ax * dt;
    vy += ay * dt;
    vz += az * dt;

    // leapfrog step 3
    x += vx * halfDt;
    y += vy * halfDt;
    z += vz * halfDt;

    // write
    d_electrons[e_offset + 0] = x;
    d_electrons[e_offset + 1] = y;
    d_electrons[e_offset + 2] = z;
    d_electrons[e_offset + 3] = vx;
    d_electrons[e_offset + 4] = vy;
    d_electrons[e_offset + 5] = vz;
}

int main() {
  std::vector<float> HostData = ReadCSV("C:\\Users\\PC\\Desktop\\e_field_5.csv");

  // print data information
    std::cout << "Total elements: " << HostData.size() << std::endl;

  // print first few elements
    int print_count = std::min(10, static_cast<int>(HostData.size()));
    for (int i = 0; i < print_count; i++) {
    std::cout << "Data[" << i << "] = " << HostData[i] << std::endl;
    }
    std::vector<float> electrons = init_Electron();

float* d_electrons;
float* d_field;
size_t electrons_size = electrons.size() * sizeof(float);
size_t field_size = HostData.size() * sizeof(float);

// allocate device memory
cudaMalloc(&d_electrons, electrons_size);
cudaMalloc(&d_field, field_size);

// copy data from host to device
cudaMemcpy(d_electrons, electrons.data(), electrons_size, cudaMemcpyHostToDevice);
cudaMemcpy(d_field, HostData.data(), field_size, cudaMemcpyHostToDevice);

int num_electrons = electrons.size() / 6;
int num_field_points = HostData.size() / 6;
float dt = 1e-12f;

int threadsPerBlock = 256;
int blocks = (num_electrons + threadsPerBlock - 1) / threadsPerBlock;

int num_iterations = static_cast<int>(SIMULATION_TIME / dt);

for (int i = 0; i < num_iterations; i++) {
  leapfrog_kernel<<<blocks, threadsPerBlock>>>(d_electrons, d_field, num_electrons, num_field_points, dt);
  cudaDeviceSynchronize();
}

cudaMemcpy(electrons.data(), d_electrons, electrons_size, cudaMemcpyDeviceToHost);

// print the first 3 electrons after kernel update
for (int i = 0; i < 3; i++) {
    std::cout << "After kernel, Electron " << i+1 << ": "
              << "x=" << electrons[i*6+0] << ", "
              << "y=" << electrons[i*6+1] << ", "
              << "z=" << electrons[i*6+2] << ", "
              << "vx=" << electrons[i*6+3] << ", "
              << "vy=" << electrons[i*6+4] << ", "
              << "vz=" << electrons[i*6+5] << std::endl;
}
return 0;
}























